'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var util = _interopDefault(require('util'));
var path = _interopDefault(require('path'));
var EventEmitter = _interopDefault(require('events'));
var globby = _interopDefault(require('globby'));
var fs = _interopDefault(require('fs-extra'));
var chalk = _interopDefault(require('chalk'));
var rollup = require('rollup');
var camelcase = _interopDefault(require('camelcase'));
var bytes = _interopDefault(require('bytes'));
var gzipSize = _interopDefault(require('gzip-size'));
var stringWidth = _interopDefault(require('string-width'));
var boxen = _interopDefault(require('boxen'));
var nodeResolvePlugin = _interopDefault(require('rollup-plugin-node-resolve'));
var commonjsPlugin = _interopDefault(require('rollup-plugin-commonjs'));
var jsonPlugin = _interopDefault(require('rollup-plugin-json'));
var uglifyPlugin = _interopDefault(require('rollup-plugin-uglify'));
var aliasPlugin = _interopDefault(require('rollup-plugin-alias'));
var replacePlugin = _interopDefault(require('rollup-plugin-replace'));
var hashbangPlugin = _interopDefault(require('rollup-plugin-hashbang'));
var isBuiltinModule = _interopDefault(require('is-builtin-module'));
var textTable = _interopDefault(require('text-table'));
var isCI = _interopDefault(require('is-ci'));
var stringifyAuthor = _interopDefault(require('stringify-author'));
var firstCommitDate = _interopDefault(require('first-commit-date'));
var UseConfig = _interopDefault(require('use-config'));
var logUpdate = _interopDefault(require('log-update'));

var supportsEmoji = process.platform !== 'win32' || process.env.TERM === 'xterm-256color';

// Fallback symbols for Windows from https://en.wikipedia.org/wiki/Code_page_437
var emoji = {
  progress: supportsEmoji ? 'â³' : 'âˆž',
  success: supportsEmoji ? 'âœ¨' : 'âˆš',
  error: supportsEmoji ? 'ðŸš¨' : 'Ã—',
  warning: supportsEmoji ? 'âš ï¸' : 'â€¼'
};

var progressPlugin = (function (_ref) {
  var logger = _ref.logger;

  var bundling = 0;
  return {
    name: 'bili-progress',
    transform: function transform(code, id) {
      logger.status(emoji.progress, 'Bundling ' + chalk.cyan(++bundling) + ' file' + (bundling > 1 ? 's' : '') + ': ' + chalk.green(path.relative(process.cwd(), id)), true);
    },
    ongenerate: function ongenerate() {
      bundling = 0;
    }
  };
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};



















var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

var template = (function (tpl, data) {
  if (typeof tpl !== 'string') {
    throw new TypeError('Expected a string in the first argument, got ' + (typeof tpl === 'undefined' ? 'undefined' : _typeof(tpl)));
  }

  if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {
    throw new TypeError('Expected an Object/Array in the second argument, got ' + (typeof data === 'undefined' ? 'undefined' : _typeof(data)));
  }

  var re = /\[(.*?)\]/g;

  return tpl.replace(re, function (_, key) {
    var ret = data;

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = key.split('.')[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var prop = _step.value;

        ret = ret ? ret[prop] : '';
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return ret || '';
  });
});

var getBanner = (function (banner, pkg) {
  if (!banner || typeof banner === 'string') {
    return banner;
  }

  pkg = (typeof banner === 'undefined' ? 'undefined' : _typeof(banner)) === 'object' ? Object.assign({}, pkg, banner) : pkg;

  var name = pkg.name;

  if (typeof name !== 'string') {
    throw new TypeError('Expect "name" in package.json to be a string but got ' + (typeof name === 'undefined' ? 'undefined' : _typeof(name)) + '.');
  }

  var version = pkg.version ? 'v' + pkg.version : '';
  var year = pkg.year;

  if (!year) {
    try {
      var date = firstCommitDate.sync();
      year = new Date(date).getFullYear();
    } catch (e) {
      year = new Date().getFullYear();
    }
  }

  var author = typeof pkg.author === 'string' ? pkg.author : _typeof(pkg.author) === 'object' ? stringifyAuthor(pkg.author) : '';
  author = author ? author : '';

  var license = pkg.license || '';

  banner = '/*!\n' + (' * ' + name + ' ' + version + '\n') + (' * (c) ' + year + '-present ' + author + '\n') + (license && ' * Released under the ' + license + ' License.\n') + ' */';

  return banner;
});

function getBabelConfig(_ref) {
  var jsx = _ref.jsx;

  return {
    presets: [[require.resolve('./babel'), { jsx: jsx }]]
  };
}

function getBiliConfig(logger) {
  var useConfig = new UseConfig({
    name: 'bili',
    files: ['package.json', '{name}.config.js', '.{name}rc']
  });

  var _useConfig$loadSync = useConfig.loadSync(),
      configPath = _useConfig$loadSync.path,
      config = _useConfig$loadSync.config;

  if (configPath) {
    logger.debug(chalk.bold('Bili config file: ' + path.relative(process.cwd(), configPath)));
  }
  return config;
}

var BiliError = function (_Error) {
  inherits(BiliError, _Error);

  function BiliError(message) {
    classCallCheck(this, BiliError);

    var _this = possibleConstructorReturn(this, (BiliError.__proto__ || Object.getPrototypeOf(BiliError)).call(this, message));

    _this.name = 'BiliError';
    return _this;
  }

  return BiliError;
}(Error);

function handleError(logger, err) {
  process.exitCode = process.exitCode || 1;
  if (err.message.includes('You must supply options.name for UMD bundles')) {
    return logger.error('You must supply ' + chalk.green('options.moduleName') + ' for UMD bundles, the easiest way is to use ' + chalk.green('--moduleName') + ' flag.\n' + getDocRef('api', 'modulename'));
  }

  logger.error(err);
}

function getDocRef(page, id) {
  return chalk.dim('\uD83D\uDCD6  https://egoist.moe/bili/#/' + page + (id ? '?id=' + id : ''));
}

var relativePath = function relativePath(p) {
  return path.relative(process.cwd(), path.resolve(p));
};

var prettyError = function prettyError(err) {
  var message = void 0;
  var stack = [];
  if (err.plugin) {
    message = '(' + err.plugin + ') ' + err.message;
    stack.push(err.codeFrame || err.snippet || err.stack);
  } else {
    message = err.message;
    if (err.loc) {
      message += ' at ' + relativePath(err.loc.file || err.id) + ':' + err.loc.line + ':' + err.loc.column;
    }
    if (err.url) {
      stack.push(err.url);
    }
    if (err.frame || err.stack) {
      stack.push(chalk.red());
    }
  }

  return {
    message: message,
    stack: stack.join('\n')
  };
};

var Logger = function () {
  function Logger() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Logger);

    this.logLevel = typeof options.logLevel === 'number' ? options.logLevel : 3;
    this.useLogUpdate = typeof options.logUpdate === 'boolean' ? options.logUpdate : true;
  }

  createClass(Logger, [{
    key: 'clear',
    value: function clear() {
      if (this.useLogUpdate) {
        logUpdate.clear();
      }
    }
  }, {
    key: 'write',
    value: function write(message) {
      var persistent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (persistent) {
        this.clear();
        console.log(message);
        return;
      }
      if (this.useLogUpdate) {
        logUpdate(message);
      } else {
        console.log(message);
      }
    }

    // Debug message
    // Always persisted

  }, {
    key: 'debug',
    value: function debug(message) {
      if (this.logLevel < 4) {
        return;
      }

      this.write(message, true);
    }

    // Normal log
    // Persist by default

  }, {
    key: 'log',
    value: function log(message, update) {
      if (this.logLevel < 3) {
        return;
      }

      this.write(message, !update);
    }

    // Warn status

  }, {
    key: 'warn',
    value: function warn(message) {
      if (this.logLevel < 2) {
        return;
      }

      this.status(emoji.warning, message);
    }

    // Error status

  }, {
    key: 'error',
    value: function error(err) {
      if (this.logLevel < 1) {
        return;
      }

      if (typeof err === 'string') {
        return this.status(emoji.error, err);
      }

      var _prettyError = prettyError(err),
          message = _prettyError.message,
          stack = _prettyError.stack;

      this.status(emoji.error, message);
      console.log(stack);
    }

    // Status message should be persisted
    // Unless `update` is set
    // Mainly used in `progress-plugin.js`

  }, {
    key: 'status',
    value: function status(emoji$$1, message, update) {
      if (this.logLevel < 3) {
        return;
      }

      if (update && this.useLogUpdate) {
        return logUpdate(emoji$$1 + '  ' + message);
      }

      this.clear();
      console.log(emoji$$1 + '  ' + message);
    }
  }]);
  return Logger;
}();

var FORMATS = ['cjs'];

var prettyBytes = function prettyBytes(v) {
  return bytes.format(v, { unitSeparator: ' ' });
};

var Bili = function (_EventEmitter) {
  inherits(Bili, _EventEmitter);
  createClass(Bili, null, [{
    key: 'generate',
    value: function generate(options) {
      return new Promise(function ($return, $error) {
        var bundle;
        return Promise.resolve(new Bili(options).bundle({ write: false })).then(function ($await_9) {
          try {
            bundle = $await_9;
            return $return(bundle);
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }.bind(this), $error);
      }.bind(this));
    }
  }, {
    key: 'write',
    value: function write(options) {
      return new Promise(function ($return, $error) {
        var bundler, startTime, buildTime, time;

        bundler = new Bili(options);
        startTime = Date.now();
        var $Try_1_Post = function () {
          try {
            return $return();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }.bind(this);var $Try_1_Catch = function (err) {
          try {
            bundler.handleError(err);
            return $Try_1_Post();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }.bind(this);try {
          return Promise.resolve(bundler.bundle()).then(function ($await_10) {
            try {
              buildTime = Date.now() - startTime;
              time = buildTime < 1000 ? buildTime + 'ms' : (buildTime / 1000).toFixed(2) + 's';

              if (!options.watch) {
                bundler.logger.status(emoji.success, chalk.green('Built in ' + time + '.'));
                return Promise.resolve(bundler.stats()).then(function ($await_11) {
                  try {
                    bundler.logger.log($await_11);
                    return $If_7.call(this);
                  } catch ($boundEx) {
                    return $Try_1_Catch($boundEx);
                  }
                }.bind(this), $Try_1_Catch);
              }

              function $If_7() {
                return $return(bundler);
              }

              return $If_7.call(this);
            } catch ($boundEx) {
              return $Try_1_Catch($boundEx);
            }
          }.bind(this), $Try_1_Catch);
        } catch (err) {
          $Try_1_Catch(err);
        }
      }.bind(this));
    }
  }]);

  function Bili() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    classCallCheck(this, Bili);

    var _this = possibleConstructorReturn(this, (Bili.__proto__ || Object.getPrototypeOf(Bili)).call(this));

    _this.logger = new Logger(options);
    _this.options = Object.assign({
      outDir: 'dist',
      filename: '[name][suffix].js',
      uglifyEs: true,
      cwd: process.cwd()
    }, getBiliConfig(_this.logger), options);
    _this.pkg = readPkg(_this.options.cwd);
    _this.bundles = {};
    _this.cssBundles = new Map();

    _this.handleError = function (err) {
      return handleError(_this.logger, err);
    };
    return _this;
  }

  createClass(Bili, [{
    key: 'stats',
    value: function stats() {
      return new Promise(function ($return, $error) {
        var _this2, bundles, sizeLimit, leading, sizeExceeded, sizes;

        _this2 = this;
        bundles = this.bundles;
        sizeLimit = this.options.sizeLimit;

        leading = '';
        sizeExceeded = false;
        return Promise.resolve(Promise.all(Object.keys(bundles).sort().map(function (filepath) {
          return new Promise(function ($return, $error) {
            var _bundles$filepath, code, relative, formatFull, gzipSizeNumber, expectedSize, sizeInfo;

            _bundles$filepath = bundles[filepath], code = _bundles$filepath.code, relative = _bundles$filepath.relative, formatFull = _bundles$filepath.formatFull;
            return Promise.resolve(gzipSize(code)).then(function ($await_12) {
              try {
                gzipSizeNumber = $await_12;
                expectedSize = sizeLimit && sizeLimit[formatFull] && bytes.parse(sizeLimit[formatFull]);
                sizeInfo = void 0;
                if (expectedSize && gzipSizeNumber > expectedSize) {
                  process.exitCode = 1;
                  sizeExceeded = true;
                  sizeInfo = chalk.red(' threshold: ' + prettyBytes(expectedSize));
                } else {
                  sizeInfo = '';
                }
                return $return([relative, prettyBytes(code.length), chalk.green(prettyBytes(gzipSizeNumber)) + sizeInfo]);
              } catch ($boundEx) {
                return $error($boundEx);
              }
            }.bind(this), $error);
          }.bind(this));
        }))).then(function ($await_13) {
          try {
            sizes = $await_13;

            if (sizeExceeded) {
              leading = chalk.red(emoji.error + '  Bundle size exceeded the limit, check below for details.\n');
            }

            return Promise.resolve(Promise.all(Array.from(this.cssBundles.keys()).sort().map(function (id) {
              return new Promise(function ($return, $error) {
                var bundle;

                bundle = _this2.cssBundles.get(id);
                return Promise.resolve(gzipSize(bundle.code)).then(function ($await_14) {
                  try {
                    sizes.push([path.relative(process.cwd(), bundle.filepath), prettyBytes(bundle.code.length), chalk.green(prettyBytes($await_14))]);
                    return $return();
                  } catch ($boundEx) {
                    return $error($boundEx);
                  }
                }.bind(this), $error);
              }.bind(this));
            }))).then(function ($await_15) {
              try {

                return $return(leading + boxen(textTable([['file', 'size', 'gzip size'].map(function (v) {
                  return chalk.bold(v);
                })].concat(toConsumableArray(sizes)), {
                  stringLength: stringWidth
                })));
              } catch ($boundEx) {
                return $error($boundEx);
              }
            }.bind(this), $error);
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }.bind(this), $error);
      }.bind(this));
    }
  }, {
    key: 'resolveCwd',
    value: function resolveCwd() {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return path.resolve.apply(path, [this.options.cwd].concat(args));
    }
  }, {
    key: 'loadUserPlugins',
    value: function loadUserPlugins(_ref) {
      var _this3 = this;

      var plugins = _ref.plugins,
          filename = _ref.filename;

      // eslint-disable-next-line array-callback-return
      return plugins.map(function (pluginName) {
        // In bili.config.js or you're using the API
        // You can require rollup plugin directly
        if ((typeof pluginName === 'undefined' ? 'undefined' : _typeof(pluginName)) === 'object') {
          return pluginName;
        }

        var pluginOptions = _this3.options[pluginName];
        if (pluginName === 'vue') {
          pluginOptions = Object.assign({
            include: ['**/*.vue'],
            css: path.resolve(_this3.options.outDir, filename.replace(/\.[^.]+$/, '.css'))
          }, pluginOptions);
        }
        var moduleName = 'rollup-plugin-' + pluginName;
        try {
          // TODO:
          // Local require is always relative to `process.cwd()`
          // Instead of `this.options.cwd`
          // We need to ensure that which is actually better
          return localRequire(moduleName)(pluginOptions);
        } catch (err) {
          handleLoadPluginError(moduleName, err);
        }
      });
    }
  }, {
    key: 'writeCSS',
    value: function writeCSS() {
      return new Promise(function ($return, $error) {
        var _this4;

        _this4 = this;
        return Promise.resolve(Promise.all(Array.from(this.cssBundles.keys()).map(function (id) {
          var _cssBundles$get = _this4.cssBundles.get(id),
              code = _cssBundles$get.code,
              map = _cssBundles$get.map,
              filepath = _cssBundles$get.filepath;

          return Promise.all([fs.writeFile(filepath, code, 'utf8'), map && fs.writeFile(filepath + '.map', map, 'utf8')]);
        }))).then(function ($await_16) {
          try {
            return $return();
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }.bind(this), $error);
      }.bind(this));
    }

    // eslint-disable-next-line complexity

  }, {
    key: 'createConfig',
    value: function createConfig(_ref2, _ref3) {
      return new Promise(function ($return, $error) {
        var _this5 = this;

        var input = _ref2.input,
            format = _ref2.format,
            formatFull = _ref2.formatFull,
            compress = _ref2.compress;
        var multipleEntries = _ref3.multipleEntries;

        var options = this.options.extendOptions ? this.options.extendOptions(this.options, {
          input: input,
          format: format,
          compress: compress
        }) : this.options;

        this.logger.debug(chalk.bold('Bili options for ' + input + ' in ' + formatFull + ':\n') + util.inspect(options, { colors: true }));

        if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') {
          return $error(new BiliError('You must return the options in `extendOptions` method!'));
        }

        var outDir = options.outDir,
            filename = options.filename,
            _options$inline = options.inline,
            inline = _options$inline === undefined ? format === 'umd' || format === 'iife' : _options$inline;


        var sourceMap = typeof options.map === 'boolean' ? options.map : compress;

        var outFilename = getFilename({
          input: input,
          format: format,
          filename: filename,
          compress: compress,
          // If it's not bundling multi-entry
          // The name can fallback to pkg name
          name: options.name || !multipleEntries && this.pkg.name
        });
        // The path to output file
        // Relative to `this.options.cwd`
        var file = this.resolveCwd(outDir, outFilename);

        var transformJS = options.js !== false;
        var jsPluginName = transformJS && (options.js || 'buble');
        var jsPlugin = transformJS && getJsPlugin(jsPluginName);
        var jsOptions = transformJS && getJsOptions(jsPluginName, options.jsx, options[jsPluginName]);

        var banner = getBanner(options.banner, this.pkg);

        var external = getArrayOption(options, 'external') || [];
        external = external.map(function (e) {
          return e.startsWith('./') ? path.resolve(e) : e;
        });
        var globals = options.globals || options.global;
        if ((typeof globals === 'undefined' ? 'undefined' : _typeof(globals)) === 'object') {
          external = [].concat(toConsumableArray(external), toConsumableArray(Object.keys(globals)));
        }

        var env = options.env;
        if (format === 'umd' || format === 'iife') {
          env = Object.assign({
            NODE_ENV: compress ? 'production' : 'development'
          }, env);
        }

        var inputOptions = {
          input: input,
          external: external,
          onwarn: function onwarn(_ref4) {
            var loc = _ref4.loc,
                frame = _ref4.frame,
                message = _ref4.message,
                code = _ref4.code,
                source = _ref4.source;

            if (options.quiet || code === 'THIS_IS_UNDEFINED') {
              return;
            }
            // Unresolved modules
            // If `inline` is not trusty there will always be this warning
            // But we only need this when the module is not installed
            // i.e. does not exist on disk
            if (code === 'UNRESOLVED_IMPORT' && source) {
              if (
              // Skip sub path for now
              source.indexOf('/') === -1 &&
              // Skip built-in modules
              !isBuiltinModule(source) &&
              // Check if the module exists
              !fs.existsSync(path.resolve('node_modules', source))) {
                _this5.logger.warn('Module "' + source + '" was not installed, you may run "' + chalk.cyan(getPackageManager() + ' add ' + source) + '" to install it!');
              }
              return;
            }
            // print location if applicable
            if (loc) {
              _this5.logger.warn(loc.file + ' (' + loc.line + ':' + loc.column + ') ' + message);
              if (frame) _this5.logger.warn(chalk.dim(frame));
            } else {
              _this5.logger.warn(message);
            }
          },
          plugins: [!isCI && process.stderr.isTTY && process.env.NODE_ENV !== 'test' && options.progress !== false && progressPlugin(this), hashbangPlugin()].concat(toConsumableArray(this.loadUserPlugins({
            filename: outFilename,
            plugins: getArrayOption(options, 'plugin') || []
          })), [require('rollup-plugin-postcss')(Object.assign({
            extract: true,
            minimize: compress,
            sourceMap: sourceMap
          }, options.postcss, {
            onExtract: function onExtract(getExtracted) {
              // Use `z` `a` to ensure the order when we log the stats
              var id = input + '::' + (compress ? 'z-compressed' : 'a-normal');
              if (!_this5.cssBundles.has(id)) {
                // Don't really need suffix for format
                var filepath = _this5.resolveCwd(outDir, outFilename.replace(/(\.(iife|cjs|es))?(\.min)?\.js$/, compress ? '.min.css' : '.css'));
                var bundle = getExtracted(filepath);

                _this5.cssBundles.set(id, Object.assign({}, bundle, {
                  filepath: filepath
                }));
              }
              // We extract CSS but never atually let `rollup-plugin-postcss` write to disk
              // To prevent from duplicated css files
              return false;
            }
          })), transformJS && jsPluginName === 'buble' && require('rollup-plugin-babel')(Object.assign({
            babelrc: false,
            exclude: 'node_modules/**',
            presets: [[require.resolve('./babel'), {
              buble: true,
              jsx: options.jsx,
              objectAssign: options.objectAssign
            }]]
          }, options.babel)), transformJS && jsPlugin(Object.assign({
            exclude: 'node_modules/**'
          }, jsOptions)), inline && nodeResolvePlugin(Object.assign({
            module: true,
            extensions: ['.js', '.json'],
            preferBuiltIns: true
          }, options.nodeResolve)), inline && commonjsPlugin(options.commonjs), jsonPlugin(), compress && uglifyPlugin(Object.assign({}, options.uglify, {
            output: Object.assign({}, options.uglify && options.uglify.output, {
              // Add banner (if there is)
              preamble: banner
            })
          }), options.uglifyEs ? require('uglify-es').minify : undefined), options.alias && aliasPlugin(options.alias), options.replace && replacePlugin(options.replace), {
            name: 'bili',
            ongenerate: function ongenerate(_, _ref5) {
              var code = _ref5.code;

              _this5.bundles[file] = {
                relative: path.relative(process.cwd(), file),
                input: input,
                format: format,
                formatFull: formatFull,
                compress: compress,
                code: code
              };
            }
          }, env && Object.keys(env).length > 0 && replacePlugin({
            values: Object.keys(env).reduce(function (res, key) {
              res['process.env.' + key] = JSON.stringify(env[key]);
              return res;
            }, {})
          })]).filter(function (v) {
            return Boolean(v);
          })
        };

        var outputOptions = {
          format: format,
          globals: globals,
          name: this.getModuleName(format),
          file: file,
          banner: banner,
          exports: options.exports,
          sourcemap: sourceMap
        };

        return $return({
          inputOptions: inputOptions,
          outputOptions: outputOptions
        });
      }.bind(this));
    }
  }, {
    key: 'bundle',
    value: function bundle() {
      var $args = arguments;return new Promise(function ($return, $error) {
        var _this6, _ref6, _ref6$write, write, inputFiles, formats, options, multipleEntries, actions;

        _this6 = this;
        _ref6 = $args.length > 0 && $args[0] !== undefined ? $args[0] : {}, _ref6$write = _ref6.write, write = _ref6$write === undefined ? true : _ref6$write;

        inputFiles = this.options.input || 'src/index.js';
        if (Array.isArray(inputFiles) && inputFiles.length === 0) {
          inputFiles = 'src/index.js';
        }

        return Promise.resolve(globby(inputFiles, { cwd: this.options.cwd }).then(function (res) {
          return res.map(function (v) {
            return relativePath(_this6.resolveCwd(v));
          });
        })).then(function ($await_17) {
          try {
            inputFiles = $await_17;

            if (inputFiles.length === 0) {
              return $error(new BiliError('No matched files to bundle.'));
            }

            formats = getArrayOption(this.options, 'format') || FORMATS;

            options = inputFiles.reduce(function (res, input) {
              return [].concat(toConsumableArray(res), toConsumableArray(formats.map(function (format) {
                var compress = format.endsWith('-min');
                return {
                  input: input,
                  format: format.replace(/-min$/, ''),
                  formatFull: format,
                  compress: compress
                };
              })));
            }, []);

            multipleEntries = inputFiles.length > 1;
            actions = options.map(function (option) {
              return new Promise(function ($return, $error) {
                var _ref7, inputOptions, outputOptions, watcher, bundle;

                return Promise.resolve(_this6.createConfig(option, {
                  multipleEntries: multipleEntries
                })).then(function ($await_18) {
                  try {
                    _ref7 = $await_18, inputOptions = _ref7.inputOptions, outputOptions = _ref7.outputOptions;


                    _this6.logger.debug(chalk.bold('Rollup input options for bundling ' + option.input + ' in ' + option.formatFull + ':\n') + util.inspect(inputOptions, { colors: true }));

                    _this6.logger.debug(chalk.bold('Rollup output options for bundling ' + option.input + ' in ' + option.formatFull + ':\n') + util.inspect(outputOptions, { colors: true }));

                    if (_this6.options.watch) {
                      watcher = rollup.watch(Object.assign({}, inputOptions, {
                        output: outputOptions,
                        watch: {
                          clearScreen: true
                        }
                      }));
                      watcher.on('event', function (e) {
                        return new Promise(function ($return, $error) {
                          if (e.code === 'ERROR' || e.code === 'FATAL') {
                            handleError(_this6.logger, e.error);
                          }
                          if (e.code === 'BUNDLE_END') {
                            process.exitCode = 0;
                            return Promise.resolve(_this6.stats()).then(function ($await_19) {
                              try {
                                _this6.logger.write($await_19);
                                return $If_8.call(this);
                              } catch ($boundEx) {
                                return $error($boundEx);
                              }
                            }.bind(this), $error);
                          }

                          function $If_8() {
                            return $return();
                          }

                          return $If_8.call(this);
                        }.bind(this));
                      });
                      return $return();
                    }

                    return Promise.resolve(rollup.rollup(inputOptions)).then(function ($await_20) {
                      try {
                        bundle = $await_20;
                        if (write) return $return(bundle.write(outputOptions));
                        return $return(bundle.generate(outputOptions));
                      } catch ($boundEx) {
                        return $error($boundEx);
                      }
                    }.bind(this), $error);
                  } catch ($boundEx) {
                    return $error($boundEx);
                  }
                }.bind(this), $error);
              }.bind(this));
            });

            return Promise.resolve(Promise.all(actions)).then(function ($await_21) {
              try {
                return Promise.resolve(nextTick(function () {
                  var bundleCount = Object.keys(_this6.bundles).length;
                  if (bundleCount > 0 && bundleCount < formats.length * inputFiles.length) {
                    var hasName = _this6.options.filename.includes('[name]');
                    var hasSuffix = _this6.options.filename.includes('[suffix]');
                    var msg = 'Multiple files are emitting to the same path.\nPlease check if ' + (hasName || inputFiles.length === 1 ? '' : '' + chalk.green('[name]') + (hasSuffix ? '' : ' or ')) + (hasSuffix ? '' : chalk.green('[suffix]')) + ' is missing in ' + chalk.green('filename') + ' option.\n' + getDocRef('api', 'filename');
                    throw new BiliError(msg);
                  }
                })).then(function ($await_22) {
                  try {
                    return Promise.resolve(this.writeCSS()).then(function ($await_23) {
                      try {

                        return $return(this);
                      } catch ($boundEx) {
                        return $error($boundEx);
                      }
                    }.bind(this), $error);
                  } catch ($boundEx) {
                    return $error($boundEx);
                  }
                }.bind(this), $error);
              } catch ($boundEx) {
                return $error($boundEx);
              }
            }.bind(this), $error);
          } catch ($boundEx) {
            return $error($boundEx);
          }
        }.bind(this), $error);
      }.bind(this));
    }
  }, {
    key: 'getModuleName',
    value: function getModuleName(format) {
      if (format !== 'umd' && format !== 'iife') return undefined;
      return this.options.moduleName || this.pkg.moduleName || (this.pkg.name ? camelcase(this.pkg.name) : undefined);
    }
  }]);
  return Bili;
}(EventEmitter);

function getSuffix(format) {
  var suffix = '';
  switch (format) {
    case 'cjs':
      suffix += '.cjs';
      break;
    case 'umd':
      break;
    case 'es':
      suffix += '.es';
      break;
    case 'iife':
      suffix += '.iife';
      break;
    default:
      throw new Error('unsupported format');
  }
  return suffix;
}

function getNameFromInput(input) {
  return path.basename(input, path.extname(input));
}

function getFilename(_ref8) {
  var input = _ref8.input,
      format = _ref8.format,
      filename = _ref8.filename,
      compress = _ref8.compress,
      name = _ref8.name;

  name = name || getNameFromInput(input);
  var suffix = getSuffix(format);
  var res = template(filename, { name: name, suffix: suffix });
  return compress ? path.basename(res, path.extname(res)) + '.min' + path.extname(res) : res;
}

function getJsOptions(name, jsx$$1, jsOptions) {
  if (name === 'babel') {
    return Object.assign({
      babelrc: process.env.NODE_ENV !== 'test'
    }, getBabelConfig({ jsx: jsx$$1 }), jsOptions);
  }

  if (name === 'typescript' || name === 'typescript2') {
    var typescript = void 0;
    try {
      typescript = localRequire('typescript');
    } catch (err) {}
    return Object.assign({
      typescript: typescript
    }, jsOptions);
  }

  if (name === 'buble') {
    return Object.assign({}, jsOptions, {
      transforms: Object.assign({
        // Skip transforming for..of
        forOf: false
      }, jsOptions && jsOptions.transforms)
    });
  }

  return jsOptions;
}

function getJsPlugin(name) {
  var req = name === 'babel' || name === 'buble' ? require : localRequire;
  var moduleName = 'rollup-plugin-' + name;
  try {
    return req(moduleName);
  } catch (err) {
    handleLoadPluginError(moduleName, err);
  }
}

function localRequire(name) {
  return require(path.resolve('node_modules', name));
}

function handleLoadPluginError(moduleName, err) {
  if (err.code === 'MODULE_NOT_FOUND' && err.message.includes(moduleName)) {
    throw new BiliError('Cannot find plugin "' + moduleName + '" in current directory!\n' + chalk.dim('You may run "npm install -D ' + moduleName + '" to install it.'));
  } else {
    throw err;
  }
}

function nextTick(fn) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      try {
        fn();
        resolve();
      } catch (err) {
        reject(err);
      }
    });
  });
}

function getArrayOption(options, name) {
  var option = options[name] || options[name + 's'];
  if (typeof option === 'string') return option.split(',');
  return option;
}

var packageManager = void 0;

function getPackageManager() {
  if (packageManager) return packageManager;
  packageManager = fs.existsSync('yarn.lock') ? 'yarn' : 'npm';
  return packageManager;
}

function readPkg() {
  var cwd = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : process.cwd();

  try {
    return require(path.resolve(cwd, 'package.json'));
  } catch (err) {
    if (err.code === 'MODULE_NOT_FOUND') {
      return {};
    }
    throw err;
  }
}

module.exports = Bili;
